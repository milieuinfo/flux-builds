"use strict";(self.webpackChunkstorybook=self.webpackChunkstorybook||[]).push([[6635],{"../../node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs":(e,n,t)=>{t.d(n,{f:()=>u});var s=t("../../node_modules/react/index.js"),r=t("../../node_modules/react-dom/client.js"),o=new Map,a=({callback:e,children:n})=>{let t=(0,s.useRef)();return(0,s.useLayoutEffect)(()=>{t.current!==e&&(t.current=e,e())},[e]),n},d=async(e,n)=>{let t=await l(n);return new Promise(n=>{t.render(s.createElement(a,{callback:()=>n(null)},e))})},i=(e,n)=>{let t=o.get(e);t&&(t.unmount(),o.delete(e))},l=async e=>{let n=o.get(e);return n||(n=r.createRoot(e),o.set(e,n)),n},c=t("../../node_modules/@storybook/blocks/dist/index.mjs"),h={code:c.XA,a:c.zE,...c.Sw},m=class extends s.Component{constructor(){super(...arguments),this.state={hasError:!1}}static getDerivedStateFromError(){return{hasError:!0}}componentDidCatch(e){let{showException:n}=this.props;n(e)}render(){let{hasError:e}=this.state,{children:n}=this.props;return e?null:s.createElement(s.Fragment,null,n)}},u=class{constructor(){this.render=async(e,n,r)=>{let o={...h,...n?.components},a=c.kQ;return new Promise((i,l)=>{t.e(814).then(t.bind(t,"../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/index.js")).then(({MDXProvider:t})=>d(s.createElement(m,{showException:l,key:Math.random()},s.createElement(t,{components:o},s.createElement(a,{context:e,docsParameter:n}))),r)).then(()=>i())})},this.unmount=e=>{i(e)}}}},"../../node_modules/@storybook/addon-docs/dist/index.mjs":(e,n,t)=>{t.d(n,{Hl:()=>s.Hl,W8:()=>s.W8,kL:()=>s.kL,ov:()=>s.ov}),t("../../node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs");var s=t("../../node_modules/@storybook/blocks/dist/index.mjs")},"./docs/e_richtlijnen/b_testen/4_technische-test-aanpak-frontend.stories.mdx":(e,n,t)=>{t.r(n),t.d(n,{__namedExportsOrder:()=>c,__page:()=>d,default:()=>l}),t("../../node_modules/react/index.js");var s=t("../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/lib/index.js"),r=t("../../node_modules/@storybook/addon-docs/dist/index.mjs"),o=t("../../node_modules/react/jsx-runtime.js");function a(e){let n=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",ul:"ul",li:"li"},(0,s.RP)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.W8,{title:"Richtlijnen/Testen/Technische Test Aanpak Frontend"}),"\n",(0,o.jsx)(n.h1,{id:"technische-test-aanpak-frontend",children:"Technische Test Aanpak Frontend"}),"\n",(0,o.jsx)(n.h2,{id:"unit-testen",children:"Unit Testen"}),"\n",(0,o.jsx)(n.p,{children:"Jest"}),"\n",(0,o.jsx)(n.h2,{id:"component-testen",children:"Component Testen"}),"\n",(0,o.jsx)(n.p,{children:"Cypress & Storybook"}),"\n",(0,o.jsx)(n.h2,{id:"te-vermijden-flaky-testen",children:"Te Vermijden: Flaky Testen"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://dev.to/codux/flaky-tests-and-how-to-deal-with-them-2id2",target:"_blank",rel:"nofollow noopener noreferrer",children:"Flaky testen"})," zijn testen die typisch lukken,\nmaar 'soms' niet. De soms hangt af van randvoorwaarden als: de snelheid van de computer waar de testen / de toepassing\nop draaien, extra belastingen van het systeem, een trager netwerk, ... .\nDes te dynamischer toepassingen worden, des te flaky-er testen worden. De oorzaak is nooit het test framework,\neen tool die de problematiek echter in acht neemt kan de flakiness wel beperken en beheersbaar maken."]}),"\n",(0,o.jsx)(n.p,{children:"Oorzaken van flakiness zijn vaak asynchrone gebeurtenissen:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["door het gebruik van promises, async/await, observables (RxJS)",(0,o.jsx)("br",{}),"\n-> eventueel ten gevolge van het maken van een reactive toepassing"]}),"\n",(0,o.jsx)(n.li,{children:"events die gebeuren vanuit de server kant: via SSE of een websocket"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"timing-problemen",children:"Timing Problemen"}),"\n",(0,o.jsx)(n.p,{children:"Selenium stamt uit 2004, een tijd waar de aanpak om een webtoepassing te schrijven was: het dynamisch maken van\nmeerdere statische pagina's. Als het dynamische er uit bestaat te antwoorden met een volledig nieuwe pagina werkt\nSelenium perfect: het selecteren en verifiÃ«ren van aanwezige DOM elementen lukt feilloos. Vanaf dat er AJAX\n(Asynchronous JavaScript And XML) gebruikt werd, lag het al moeilijker. De feitelijke DOM-structuur wijzigt dan\nten gevolge van gebruiker acties. Doordat AJAX bewust en gecontroleerd gebruikt werd, viel het nog wel mee om\neen Selenium test te schrijven. Je gebruikt typisch het patroon: wachten tot 'iets verwacht' gebeurt, om daarna\nverder te gaan."}),"\n",(0,o.jsxs)(n.p,{children:["Bij een SPA is het echter minder eenduidig wat er in de DOM gebeurt, zie hiervoor de uitgebreidere uitleg m.b.t.\n",(0,o.jsx)(n.a,{href:"/docs/richtlijnen-testen-selenium-en-cypress--documentatie#eenduidigheid",children:"eenduidigheid"}),"."]})]})}let d=()=>{throw Error("Docs-only story")};d.parameters={docsOnly:!0};let i={title:"Richtlijnen/Testen/Technische Test Aanpak Frontend",tags:["stories-mdx"],includeStories:["__page"]};i.parameters=i.parameters||{},i.parameters.docs={...i.parameters.docs||{},page:function(e={}){let{wrapper:n}=Object.assign({},(0,s.RP)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}};let l=i,c=["__page"]},"../../node_modules/react-dom/client.js":(e,n,t)=>{var s=t("../../node_modules/react-dom/index.js");n.createRoot=s.createRoot,n.hydrateRoot=s.hydrateRoot}}]);