"use strict";(self.webpackChunkstorybook=self.webpackChunkstorybook||[]).push([[6635],{"../../node_modules/@storybook/addon-docs/dist/index.mjs":(e,n,t)=>{t.d(n,{Hl:()=>s.Hl,W8:()=>s.W8,kL:()=>s.kL,ov:()=>s.ov}),t("../../node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs");var s=t("../../node_modules/@storybook/addon-docs/node_modules/@storybook/blocks/dist/index.mjs")},"./docs/e_richtlijnen/b_testen/4_technische-test-aanpak-frontend.stories.mdx":(e,n,t)=>{t.r(n),t.d(n,{__namedExportsOrder:()=>c,__page:()=>o,default:()=>l}),t("../../node_modules/react/index.js");var s=t("../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/lib/index.js"),r=t("../../node_modules/@storybook/addon-docs/dist/index.mjs"),i=t("../../node_modules/react/jsx-runtime.js");function a(e){let n=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",ul:"ul",li:"li"},(0,s.RP)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.W8,{title:"Richtlijnen/Testen/Technische Test Aanpak Frontend"}),"\n",(0,i.jsx)(n.h1,{id:"technische-test-aanpak-frontend",children:"Technische Test Aanpak Frontend"}),"\n",(0,i.jsx)(n.h2,{id:"unit-testen",children:"Unit Testen"}),"\n",(0,i.jsx)(n.p,{children:"Jest"}),"\n",(0,i.jsx)(n.h2,{id:"component-testen",children:"Component Testen"}),"\n",(0,i.jsx)(n.p,{children:"Cypress & Storybook"}),"\n",(0,i.jsx)(n.h2,{id:"te-vermijden-flaky-testen",children:"Te Vermijden: Flaky Testen"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://dev.to/codux/flaky-tests-and-how-to-deal-with-them-2id2",target:"_blank",rel:"nofollow noopener noreferrer",children:"Flaky testen"})," zijn testen die typisch lukken,\nmaar 'soms' niet. De soms hangt af van randvoorwaarden als: de snelheid van de computer waar de testen / de toepassing\nop draaien, extra belastingen van het systeem, een trager netwerk, ... .\nDes te dynamischer toepassingen worden, des te flaky-er testen worden. De oorzaak is nooit het test framework,\neen tool die de problematiek echter in acht neemt kan de flakiness wel beperken en beheersbaar maken."]}),"\n",(0,i.jsx)(n.p,{children:"Oorzaken van flakiness zijn vaak asynchrone gebeurtenissen:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["door het gebruik van promises, async/await, observables (RxJS)",(0,i.jsx)("br",{}),"\n-> eventueel ten gevolge van het maken van een reactive toepassing"]}),"\n",(0,i.jsx)(n.li,{children:"events die gebeuren vanuit de server kant: via SSE of een websocket"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timing-problemen",children:"Timing Problemen"}),"\n",(0,i.jsx)(n.p,{children:"Selenium stamt uit 2004, een tijd waar de aanpak om een webtoepassing te schrijven was: het dynamisch maken van\nmeerdere statische pagina's. Als het dynamische er uit bestaat te antwoorden met een volledig nieuwe pagina werkt\nSelenium perfect: het selecteren en verifiÃ«ren van aanwezige DOM elementen lukt feilloos. Vanaf dat er AJAX\n(Asynchronous JavaScript And XML) gebruikt werd, lag het al moeilijker. De feitelijke DOM-structuur wijzigt dan\nten gevolge van gebruiker acties. Doordat AJAX bewust en gecontroleerd gebruikt werd, viel het nog wel mee om\neen Selenium test te schrijven. Je gebruikt typisch het patroon: wachten tot 'iets verwacht' gebeurt, om daarna\nverder te gaan."}),"\n",(0,i.jsxs)(n.p,{children:["Bij een SPA is het echter minder eenduidig wat er in de DOM gebeurt, zie hiervoor de uitgebreidere uitleg m.b.t.\n",(0,i.jsx)(n.a,{href:"/docs/richtlijnen-testen-selenium-en-cypress--documentatie#eenduidigheid",children:"eenduidigheid"}),"."]})]})}let o=()=>{throw Error("Docs-only story")};o.parameters={docsOnly:!0};let d={title:"Richtlijnen/Testen/Technische Test Aanpak Frontend",tags:["stories-mdx"],includeStories:["__page"]};d.parameters=d.parameters||{},d.parameters.docs={...d.parameters.docs||{},page:function(e={}){let{wrapper:n}=Object.assign({},(0,s.RP)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}};let l=d,c=["__page"]}}]);