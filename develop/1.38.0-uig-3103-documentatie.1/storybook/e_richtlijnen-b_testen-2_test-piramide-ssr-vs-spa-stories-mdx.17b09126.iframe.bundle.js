(self.webpackChunkstorybook=self.webpackChunkstorybook||[]).push([[9338],{"../../node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs":(e,n,t)=>{"use strict";t.d(n,{f:()=>u});var r=t("../../node_modules/react/index.js"),o=t("../../node_modules/react-dom/client.js"),i=new Map,s=({callback:e,children:n})=>{let t=(0,r.useRef)();return(0,r.useLayoutEffect)(()=>{t.current!==e&&(t.current=e,e())},[e]),n},a=async(e,n)=>{let t=await l(n);return new Promise(n=>{t.render(r.createElement(s,{callback:()=>n(null)},e))})},d=(e,n)=>{let t=i.get(e);t&&(t.unmount(),i.delete(e))},l=async e=>{let n=i.get(e);return n||(n=o.createRoot(e),i.set(e,n)),n},c=t("../../node_modules/@storybook/blocks/dist/index.mjs"),p={code:c.XA,a:c.zE,...c.Sw},m=class extends r.Component{constructor(){super(...arguments),this.state={hasError:!1}}static getDerivedStateFromError(){return{hasError:!0}}componentDidCatch(e){let{showException:n}=this.props;n(e)}render(){let{hasError:e}=this.state,{children:n}=this.props;return e?null:r.createElement(r.Fragment,null,n)}},u=class{constructor(){this.render=async(e,n,o)=>{let i={...p,...n?.components},s=c.kQ;return new Promise((d,l)=>{t.e(814).then(t.bind(t,"../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/index.js")).then(({MDXProvider:t})=>a(r.createElement(m,{showException:l,key:Math.random()},r.createElement(t,{components:i},r.createElement(s,{context:e,docsParameter:n}))),o)).then(()=>d())})},this.unmount=e=>{d(e)}}}},"../../node_modules/@storybook/addon-docs/dist/index.mjs":(e,n,t)=>{"use strict";t.d(n,{Hl:()=>r.Hl,W8:()=>r.W8,kL:()=>r.kL,ov:()=>r.ov}),t("../../node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs");var r=t("../../node_modules/@storybook/blocks/dist/index.mjs")},"../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/lib/index.js":(e,n,t)=>{"use strict";t.d(n,{BN:()=>o,RP:()=>s,gz:()=>i,xA:()=>d});var r=t("../../node_modules/react/index.js");let o=r.createContext({});function i(e){return function(n){let t=s(n.components);return r.createElement(e,{...n,allComponents:t})}}function s(e){let n=r.useContext(o);return r.useMemo(()=>"function"==typeof e?e(n):{...n,...e},[n,e])}let a={};function d({components:e,children:n,disableParentContext:t}){let i;return i=t?"function"==typeof e?e({}):e||a:s(e),r.createElement(o.Provider,{value:i},n)}},"./docs/e_richtlijnen/b_testen/2_test-piramide-ssr-vs-spa.stories.mdx":(e,n,t)=>{"use strict";t.r(n),t.d(n,{__namedExportsOrder:()=>u,__page:()=>c,default:()=>m}),t("../../node_modules/react/index.js");var r=t("../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/lib/index.js"),o=t("../../node_modules/@storybook/addon-docs/dist/index.mjs");let i=t.p+"static/media/ssr-vs-spa.e9280156.png",s=t.p+"static/media/ssr-test-piramide.a3739d9b.png",a=t.p+"static/media/spa-test-piramide.d61997cb.png";var d=t("../../node_modules/react/jsx-runtime.js");function l(e){let n=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",ul:"ul",li:"li",blockquote:"blockquote"},(0,r.RP)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(o.W8,{title:"Richtlijnen/Testen/Test Piramide SSR vs SPA"}),"\n",(0,d.jsx)(n.h1,{id:"test-piramide-ssr-vs-spa",children:"Test Piramide: SSR vs SPA"}),"\n",(0,d.jsx)(n.h2,{id:"srr-vs-spa",children:"SRR vs SPA"}),"\n",(0,d.jsx)("br",{}),"\n",(0,d.jsx)("img",{src:i,alt:"Ssr vs Spa",height:"450px"}),"\n",(0,d.jsx)(n.h2,{id:"testen-van-een-ssr",children:"Testen van een SSR"}),"\n",(0,d.jsx)(n.p,{children:"Vroeger werden toepassingen typisch gebouwd als server-side rendering applicaties. Voor hedendaagse toepassingen die\ndichter aanleunen bij een website dan bij een complexere webtoepassing kan SSR nog steeds de voorkeur genieten.\nVeel toepassingen bij Departement Omgeving zijn als SSR-toepassing geschreven. De frontend werkt dan niet onafhankelijk\nvan de backend maar zit erin vervat, het is een backend gestuurde toepassing. Er zullen unit en integratie testen zijn,\nmaar hoofdzakelijk voor de Java code die eerder backend gefocused is. Voor de frontend testen is het dan zinvol je te\nbeperken tot e2e-testen. Die e2e-testen zijn dan wel de enige frontend testen en zouden dan best zowel het happy\nals (beperkt) het unhappy pad moeten afdekken. Logica zal zich eerder in de Java code bevinden, niet alle varianten van\ngeldige en ongeldige input dient dus via de frontend afgetest te worden daar dit al op een lager niveau in de piramide\ngetest werd."}),"\n",(0,d.jsx)(n.p,{children:"Voor een SSR-toepassing ziet de test piramide er conceptueel als volgt uit:"}),"\n",(0,d.jsx)("img",{src:s,alt:"Ssr Test Piramide",height:"350px"}),"\n",(0,d.jsx)("br",{}),"\n",(0,d.jsx)(n.p,{children:"De feitelijke backend test aanpak kan fijner uitgetekend worden, dit is echter buiten de scope van dit document (dat\nzich beperkt tot frontend)."}),"\n",(0,d.jsx)(n.h2,{id:"testen-van-een-spa",children:"Testen van een SPA"}),"\n",(0,d.jsxs)(n.p,{children:["Voor complexere web toepassingen heeft de\n",(0,d.jsx)(n.a,{href:"https://nl.wikipedia.org/wiki/Single_Page_Application",target:"_blank",rel:"nofollow noopener noreferrer",children:"Single Page Application"})," aanpak de voorkeur. Een SPA kan je\nzien als een volwaardige toepassing die eenmalig ingeladen wordt in de browser (of aanwezig is op bvb. een tablet) en\ncommuniceert met 1 (of meerdere) backends. In tegenstelling tot een SSR kan je om een SPA te testen wel de volledige\ntest piramide in beschouwing nemen. Een uitgebreidere uitleg hierover vind je in het Medium artikel\n",(0,d.jsx)(n.a,{href:"https://medium.com/inspiredbrilliance/testing-single-page-applications-b4001adc6452",target:"_blank",rel:"nofollow noopener noreferrer",children:"Testing Single Page Applications"}),",\neventueel vind je ",(0,d.jsx)("a",{href:"testing-single-page-applications-medium.pdf",target:"_blank",children:"hier"})," een kopie."]}),"\n",(0,d.jsx)(n.p,{children:"Samengevat komt het erop neer dat een goed geschreven SPA uit onderdelen bestaat die op test vlak alliëren met de lagen\nvan de test piramide:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"functionele logica - ongerelateerd aan UI zaken - zit afgebakend, hier tegenover worden unit testen geschreven"}),"\n",(0,d.jsx)(n.li,{children:"basis (herbruikbare) UI-functionaliteit zit in componenten, daar worden component testen voor geschreven - er\ndient een opzet voorzien te worden om componenten standalone te kunnen testen"}),"\n",(0,d.jsx)(n.li,{children:"componenten kunnen gegroepeerd worden, denk bvb. aan complexere formulieren of wizards, die kan je geïntegreerd\ntesten (component integratie testen)"}),"\n",(0,d.jsx)(n.li,{children:"afhankelijk van de maturiteit al dan niet in combinatie met een framework kan de toepassing in modules opgesplitst\nworden, een module (die bestaat uit een store, een router, componenten, ...) kan onafhankelijk van andere modules\ngetest worden, dit zijn dan ook integratie testen"}),"\n",(0,d.jsx)(n.li,{children:"de feitelijke eindtoepassing kan je e2e testen, afhankelijk van de kwaliteit van de backend en de team-samenstelling\nkan je e2e testen t.o.v. een draaiende backend of opteren om de backend-calls te mocken"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["Bij een SPA zit er meer code en logica in de frontend dan bij een SSR-toepassing. Daar er echter met een scripting taal\ngewerkt wordt is het aan te bevelen een extra kwaliteitslaag toe te voegen: een linter of een transpiler. In de backend\nheb je - vaak zonder te beseffen - een compiler die er voor zorgt dat de code die je test minstens 'loopt'. In de\nfrontend heb je die garantie niet, door bvb. in ",(0,d.jsx)(n.a,{href:"https://www.typescriptlang.org/",target:"_blank",rel:"nofollow noopener noreferrer",children:"TypeScript"})," te werken en een\ntranspiler toe te voegen verhoog je dus met een minimale inspanning al de kwaliteit."]}),"\n",(0,d.jsx)(n.p,{children:"Voor een SPA ziet de volledige test piramide er als volgt uit:"}),"\n",(0,d.jsx)("img",{src:a,alt:"Spa Test Piramide",height:"450px"}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"Dit lijkt mogelijks nodeloos 'gelaagd' of 'complex' maar is het niet. Een transpiler / linter (wat optioneel is maar\naanbevolen wordt) maakt deel uit van het ontwikkel / build proces (net zoals bij Java ontwikkeling). Unit testen zijn\ntypisch beperkt, de overige testen (component / component integratie / e2e) kan je zo opzetten dat het technische\nvarianten zijn; zodat ze praktisch niet aanvoelen als een ander type test."}),"\n"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"1 van de doelen van een SPA is de backend simpeler, eenduidiger en meer stateless te maken. Hierdoor\nverschuift een deel van de logica en complexiteit naar de frontend. Er zal dus meer getest worden in de frontend,\nmaar minder in de backend t.o.v. een SSR-toepassing."}),"\n"]})]})}let c=()=>{throw Error("Docs-only story")};c.parameters={docsOnly:!0};let p={title:"Richtlijnen/Testen/Test Piramide SSR vs SPA",tags:["stories-mdx"],includeStories:["__page"]};p.parameters=p.parameters||{},p.parameters.docs={...p.parameters.docs||{},page:function(e={}){let{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}};let m=p,u=["__page"]},"../../node_modules/memoizerific sync recursive":e=>{function n(e){var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id="../../node_modules/memoizerific sync recursive",e.exports=n},"../../node_modules/react-dom/client.js":(e,n,t)=>{"use strict";var r=t("../../node_modules/react-dom/index.js");n.createRoot=r.createRoot,n.hydrateRoot=r.hydrateRoot},"../../node_modules/react/cjs/react-jsx-runtime.production.min.js":(e,n,t)=>{"use strict";/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r=t("../../node_modules/react/index.js"),o=Symbol.for("react.element"),i=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function l(e,n,t){var r,i={},l=null,c=null;for(r in void 0!==t&&(l=""+t),void 0!==n.key&&(l=""+n.key),void 0!==n.ref&&(c=n.ref),n)s.call(n,r)&&!d.hasOwnProperty(r)&&(i[r]=n[r]);if(e&&e.defaultProps)for(r in n=e.defaultProps)void 0===i[r]&&(i[r]=n[r]);return{$$typeof:o,type:e,key:l,ref:c,props:i,_owner:a.current}}n.Fragment=i,n.jsx=l,n.jsxs=l},"../../node_modules/react/jsx-runtime.js":(e,n,t)=>{"use strict";e.exports=t("../../node_modules/react/cjs/react-jsx-runtime.production.min.js")}}]);